package Parse;

action code {: static Symbol.Symbol sym(String s) {
	         return Symbol.Symbol.symbol(s);
	        }
	    :};

parser code  {: 
  Lexer lexer;

  public void syntax_error(java_cup.runtime.Symbol current) {
   report_error("Syntax error (" + current.sym + ")", current);
  }

  ErrorMsg.ErrorMsg errorMsg;

  public void report_error(String message, java_cup.runtime.Symbol info) {
      errorMsg.error(info.left, message);
  }

  public Grm(Lexer l, ErrorMsg.ErrorMsg err) {
    this();
    errorMsg=err;
    lexer=l;
  }
:};

scan with {: return lexer.nextToken(); :};

terminal String ID, STRING;
terminal Integer INT_LITERAL;
terminal EOF, INT, GT, DIVIDE, COLON, ELSE, B_OR, NIL, DO, GE, error, LT, MINUS, FOR, TIMES, COMMA, 
  LE, ASSIGN, DOT, LPAREN, RPAREN, IF, SEMICOLON, WHILE, LBRACK, RBRACK, VAR, BREAK, AND, PLUS, 
  LBRACE, RBRACE, EQ, AUTO, STRUCT, SWITCH, CASE, ENUM, REGISTER, TYPEDEF, CHAR, EXTERN, RETURN, UNION, CONST, 
  FLOAT, SHORT, UNSIGNED, CONTINUE, SIGNED, VOID, DEFAULT, GOTO, SIZEOF, VOLATILE, STATIC, STAR, POUND, PLUS_PLUS, 
  MINUS_MINUS, TILDA, PERCENT, DOUBLE_LEFT_ARROW, DOUBLE_RIGHT_ARROW, NOT_EQUAL, CARROT, AND_AND, OR, 
  QUESTION_MARK, STAR_EQUAL, SLASH_EQUAL, PERCENT_EQUAL, PLUS_EQUAL, MINUS_EQUAL, DOUBLE_LEFT_ARROW_EQUAL, 
  DOUBLE_RIGHT_ARROW_EQUAL, AND_EQUAL, CARROT_EQUAL, OR_EQUAL, POUND_POUND;

non terminal Absyn.Exp          Exp;
non terminal Absyn.Var          Var;

start with Exp;

Exp ::= error:e
	  {: RESULT = new Absyn.SeqExp(eleft, null); :}
	| Var:v
	  {: RESULT = new Absyn.VarExp(vleft, v); :}
	;

Var ::=   ID:n
	  {: RESULT = new Absyn.SimpleVar(nleft, sym(n)); :}
	;
